
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<title>Hello</title>

<!-- keywords -->


<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="Hello">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hello">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="XU LIN">
<meta name="twitter:card" content="summary">

<link rel="alternative" href="/atom.xml" title="Hello"
	type="application/atom+xml">
<link rel="icon" href="">
<link rel="stylesheet" href="/css/style.css">


<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>


<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>



<meta name="generator" content="Hexo 4.2.1">
</head>
<body>
	<div id="container">
		<div id="particles-js"></div>
		<div class="left-col">
			<div class="overlay"></div>
			<div class="intrude-less">
				<header id="header" class="inner">
					<a href="/" class="profilepic"> <img
						lazy-src="/img/微信图片_20200901134748.jpg" class="js-avatar">

					</a>

					<hgroup>
						<h1 class="header-author">
							<a href="/">XU LIN</a>
						</h1>
					</hgroup>




					<div class="switch-btn">
						<div class="icon">
							<div class="icon-ctn">
								<div class="icon-wrap icon-house" data-idx="0">
									<div class="birdhouse"></div>
									<div class="birdhouse_holes"></div>
								</div>
								<div class="icon-wrap icon-ribbon hide" data-idx="1">
									<div class="ribbon"></div>
								</div>

								<div class="icon-wrap icon-link hide" data-idx="2">
									<div class="loopback_l"></div>
									<div class="loopback_r"></div>
								</div>


							</div>

						</div>
						<div class="tips-box hide">
							<div class="tips-arrow"></div>
							<ul class="tips-inner">
								<li>菜单</li>
								<li>标签</li>
								<li>友情链接</li>
							</ul>
						</div>
					</div>


					<div class="switch-area">
						<div class="switch-wrap">
							<section class="switch-part switch-part1">
								<nav class="header-menu">
									<ul>

										<li><a href="/">主页</a></li>

										<li><a href="/archives">所有文章</a></li>

									</ul>
								</nav>
								<nav class="header-nav">
									<div class="social"></div>
								</nav>
							</section>


							<section class="switch-part switch-part2">
								<div class="widget tagcloud" id="js-tagcloud"></div>
							</section>



							<section class="switch-part switch-part3">
								<div id="js-friends">

									<a target="_blank" class="main-nav-link switch-friends-link"
										href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
								</div>
							</section>
						</div>
					</div>
				</header>
			</div>
		</div>
		<div class="mid-col">
			<nav id="mobile-nav">
				<div class="overlay">
					<div class="slider-trigger"></div>
					<h1 class="header-author js-mobile-header hide">XU LIN</h1>
				</div>
				<div class="intrude-less">
					<header id="header" class="inner">
						<div class="profilepic">
							<img lazy-src="/img/微信图片_20200901134748.jpg" class="js-avatar">
						</div>
						<hgroup>
							<h1 class="header-author">XU LIN</h1>
						</hgroup>

						<nav class="header-menu">
							<ul>

								<li><a href="/">主页</a></li>

								<li><a href="/archives">所有文章</a></li>

								<div class="clearfix"></div>
							</ul>
						</nav>
						<nav class="header-nav">
							<div class="social"></div>
						</nav>
					</header>
				</div>
			</nav>
			<div class="body-wrap">

				<article id="post-hello-world" class="article article-type-post"
					itemscope itemprop="blogPost">

					<div class="article-meta">
						<a href="/2020/06/19/hello-world/" class="article-date"> <time
								datetime="2020-06-19T02:24:54.719Z" itemprop="datePublished">2020-06-19</time>
						</a>
					</div>

					<div class="article-inner">

						<input type="hidden" class="isFancy" />


						<header class="article-header">


							<h1 itemprop="name">
								<a class="article-title" href="/2020/06/19/hello-world/">
									Hello World </a>
							</h1>


						</header>


						<div class="article-entry" itemprop="articleBody">

							<p>Welcome to XU LIN Blog .</p>
							<h1 id="Sql Server">
								<p>C#</p>
							</h1>
<h2 id=""><font size="5" color="Aqua" ><p>1.获得集合里面的所有控件</p></font></h2>
<figure class="highlight bash"><pre><span class="line"><font size="4">
<font  color="DeepSkyBlue" >--//按钮的模拟点击事件</font>
button1.PerformClick();

GetPanl(tPanel1);
public void GetPanl(Control control)
{
    Control.ControlCollection controlCollection = control.Controls;
    int i = 0;
    foreach (Control item in controlCollection)
    {
        if (item is System.Windows.Forms.Button)
        {
            item.Text = "我是第" + i + "个";
            i++;
        }
    }
}
</span></pre></figure></font>
<font size="4"></font></span></pre></figure>
<h2 id=""><font size="5" color="Aqua" ><p>2.C#的基本使用</p></font></h2>			
<figure class="highlight bash">
<pre><span class="line"><font size="4">	
<font  color="DeepSkyBlue" >--//项目属性窗口生成事件</font>
生成前喝生成后的简单解释 
就是读取.bat 文件，根据配置赋值相关的dll到文件夹下
如果不会写.bat   手动复制dll
<font  color="DeepSkyBlue" >--//CMD 命令窗口创建服务</font>
如果服务启动失败，搜索事件查看器  可以看到错报的代码位置
sc create ServiceName binPath= "path.exe" 
<font  color="DeepSkyBlue" >--//简单线程使用</font>
new Thread(delegate ()
{
    StartScanLo();  //方法
    Thread.Sleep(100);
}).Start() ;
--//
Thread thread = new Thread(方法);
thread.Start();
<font  color="DeepSkyBlue" >--//textbox只能输入数字和小数</font>
https://www.cnblogs.com/liuqifeng/p/9148801.html
<font  color="DeepSkyBlue" >--//路径的截取Path类还有很多截取方法</font>
https://blog.csdn.net/DxgTeam/article/details/108481373
Substring（开始位置，截取长度）
Substring（开始位置截取到结束）要给参数
DirectoryInfo info = new DirectoryInfo(string路径);
String path = info.Parent.Parent.FullName; 返回上一级（一个Parent是一个级别/）
string path ="E:\新建文件夹\0.bmp";
Path.GetDirectoryName(path）;return E:\新建文件夹
Path.GetFileName();return ".0bmp"
invoke和begininvoke 区别
https://www.cnblogs.com/lsgsanxiao/p/5523282.html
<font  color="DeepSkyBlue" >--//图片处理</font>
//图片填充inmgebox
pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;
pictureBox1.BackgroundImageLayout = ImageLayout.Stretch;
//截取指定图片
https://www.cnblogs.com/zhangruifeng/p/5986463.html
或者：
Bitmap bmp = new Bitmap(@"D:\Inked1_LI.bmp");
Bitmap bmp2 = bmp.Clone(new Rectangle(160,2200, 5200, 6200), bmp.PixelFormat);
pictureBox2.Image = (Image)bmp2;
bmp2.Save(@"d:\bmp2.jpg");
<font  color="DeepSkyBlue" >--//combox赋值</font>
string[] str = new string[] {"第一个","第二个","第三个","第四个"};
comboBox1.DataSource = str;
或者
this.cboColum.Properties.Items.Add("111");

<font  color="DeepSkyBlue" >--//转换时间格式</font>
G  YYYY-MM-dd hh:mm:sss
F YYYY年MM月dd日 hh:mm:ss
string.Format("dasdasdas+  {0:G}",DateTime.Now)
<font  color="DeepSkyBlue" >--//基础篇</font>
1.常量 const 一旦确定不变
<font  color="DeepSkyBlue" >--//句柄</font>
一个字节等于8个bit（bit可以使0或1） （字节 0-255）  一个字母代表一个字节，一个汉字代表两个根据编码的不同代表的也不一样
这算是Windows操作系统底层的概念，每个窗口的唯一标识，整数。
实际使用，设备提供的方法参数是hWnd c++类型， c# intpart
IntPtr hWnd = this.Handle;0x0000000000010a04   0x代表十六进制
//复制
HANDLE（句柄）是Windows操作系统中的一个概念。在Windows程序中，有各种各样的资源（窗口、图标、光标等），系统在创建这些资源时会为它们分配内存，
并返回标示这些资源的标示号，即句柄。句柄指的是一个核心对象在某一个进程中的唯一索引，而不是指针。由于地址空间的限制，句柄所标识的内容对进程是不可见的，
只能由操作系统通过进程句柄列表来进行维护。句柄列表：每个进程都要创建一个句柄列表，这些句柄指向各种系统资源，比如信号量，线程，和文件等，进程中的所有线程都可以访问这些资源。
<font  color="DeepSkyBlue" >--//获在有数据的情况下修改table的某一列类型</font>
private DataTable UpdateDataTable(DataTable argDataTable)
 {
            DataTable dtResult = new DataTable();
            //克隆表结构
            dtResult = argDataTable.Clone();
            foreach (DataColumn col in dtResult.Columns)
            {
                if (col.ColumnName == "a")
                {
                    //修改列类型
                    col.DataType = typeof(int);
                }
            }
            foreach (DataRow row in argDataTable.Rows)
            {
                DataRow rowNew = dtResult.NewRow();
                rowNew["列名"] = row["columname"];
                //修改记录值
                rowNew["a"] = int.Parse(row["a"].ToString());
                rowNew["columname"] = row["columname"];              
                dtResult.Rows.Add(rowNew);
            }
            return dtResult;
}
<font  color="DeepSkyBlue" >--//获得table的某一列转换成集合</font>
//Linq
var l1 = (from d in dt.AsEnumerable() select d.Field<int>("ID")).ToList();
//lambda
var l2 = dt.AsEnumerable().ToList().Select(x => x.Field<int>("ID")).ToList();
//使用orderby关键字进行排序
List<string> listJobTitle = (from d in dvBaseInfo.ToTable().AsEnumerable() orderby d.Field<int>("OrderNo") select d.Field<string>("VName")).ToList();
<font  color="DeepSkyBlue" >--//抽象类</font>
abstract 修饰词修饰抽象类
类可以有无抽象的方法和属性，但是有抽象方法的类肯定是抽象类
继承抽象类的必须实现里面的抽象方法，除非此类也是抽象类
<font  color="DeepSkyBlue" >--//C# 选择table的某一列转化成集合</font>
//选择table的某一列，转换成list集合
var stra = (from d in dataTable.AsEnumerable()
            select d.Field<string>("FAB")
           ).ToList();
//去集合的要给范围（int ，int）
List<string> a  = stra.GetRange(1,5);
<font  color="DeepSkyBlue" >--//C# 中的Async 和 Await 的用法详解</font>
同步按程序的顺序执行  异步同时运行
参考：https://www.cnblogs.com/ma8023/p/11677394.html
参考：https://www.cnblogs.com/zhaoshujie/p/11192036.html
同时执行两个两个方法  异步的方法是启用的别的线程 
用async来修饰一个方法，表明这个方法是异步的，声明的方法的返回类型必须为：void或Task或Task<TResult>。
方法内部必须含有await修饰的方法，如果方法内部没有await关键字修饰的表达式，哪怕函数被async修饰也只能算作同步方法，执行的时候也是同步执行的。
被await修饰的只能是Task或者Task<TResule>类型，通常情况下是一个返回类型是Task/Task<TResult>的方法，
当然也可以修饰一个Task/Task<TResult>变量，await只能出现在已经用async关键字修饰的异步方法中。
上面代码中就是修饰了一个变量ResultFromTimeConsumingMethod。
<font  color="DeepSkyBlue" >--//c#中的三元运算符</font>
C#中有一个三元运算符“?:”，语法为：条件表达式？表达式1：表达式2；
该操作首先求出条件表达式的值(bool类型)，为true时调用表达式1，为flase时调用表达式2。其逻辑为：“如果为真执行第一个，否则执行第二个。
其实和if else 差不多 例如  a=3>4?3:4;输出为4。       a=3<4?3:4;输出为3。
<font  color="DeepSkyBlue" >--//c#   split</font>
string [] str =  string.split（''）;
split()首先是一个分隔符，它会把字符串按照split(‘ 字符’)里的字符把字符串分割成数组，然后存给一个数组对象。
<font  color="DeepSkyBlue" >--//集合转换数组</font>
List<int> list1 = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int[] intList= list1.ToArray();
---------------------***-------
List<TreeNode> treeNodes = new List<TreeNode>();
TreeNode[] treeNodess = treeNodes.ToArray<TreeNode>();
<font  color="DeepSkyBlue" >--//c#中交集交集、并集、差集</font>
Except()差集、Intersect()交集，Union()并集  
list集合  和datatable都可以使用
Intersect 交集，Except 差集，Union 并集
int[] oldArray = { 1, 2, 3, 4, 5 };
int[] newArray = { 2, 4, 5, 7, 8, 9 };
var jiaoJi = oldArray.Intersect(newArray).ToList();//2,4,5
var oldChaJi = oldArray.Except(newArray).ToList();//1,3
var newChaJi = newArray.Except(oldArray).ToList();//7,8,9
var bingJi = oldArray.Union(newArray).ToList();//1,2,3,4,5,7,8,9
datatable的参考 
https://www.cnblogs.com/Anthony518/p/12009561.html
<font  color="DeepSkyBlue" >--//讲项目打包成.exe应用程序</font>
生成后再Debug下有  两个文件.exe和msi  一起
https://www.cnblogs.com/kiba/p/11052619.html
<font  color="DeepSkyBlue" >--//c# ref out</font>
简单理解 传入参数 进入修改方法内修改，执行完参数没改变，案例 x y 替换方法， ref 使用前必须初始化复制，侧重于方法内修改参数
out 侧重输出，该参数在创建时，可以不设置初始值，但是在方法中必须初始化，out侧重于输出；
<font  color="DeepSkyBlue" >--//时间处理</font>
 new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, 7, 30, 0);-------2021-01-05 07:30
 <font  color="DeepSkyBlue" >--//List集合去重</font>
 List<string> list = new List<string>():
list.Distinct().ToList()
list.Distinct().ToList().Count()数量
list.Distinct().ToList()[0]下标获得值
<font  color="DeepSkyBlue" >--//获得指定时间的天数</font>
DateTime.DaysInMonth（int,int）年份，月份
List<string> columnNameList = new List<string>();
 foreach (DataColumn col in dataDt.Columns)
{
        columnNameList.Add(col.ColumnName);//获取到DataColumn列对象的列名
}
<font  color="DeepSkyBlue" >--//is  和 as 的使用</font>
参考https://blog.csdn.net/pitt_xiong/article/details/7409875
比较 是否是这个类型   
is的话返回 bool  true和false
as的使用时失败 返回null 
<font  color="DeepSkyBlue" >--//treeView1的使用 添加值</font>
private void TressView_Load(object sender, EventArgs e)
{
    TreeNode[]  FuJieDian = new TreeNode[10];
    for (int i = 0; i < 10; i++)
    {
        TreeNode children = new TreeNode("我是第"+i.ToString(), ZIGetTreeNodes());
        FuJieDian[i] = children;
    }    
    treeView1.Nodes.AddRange(FuJieDian);
}
//数组的方式
public TreeNode[] ZIGetTreeNodes() {
    TreeNode[] children = new TreeNode[5];
    for (int i = 0; i < 5; i++)
    {
        TreeNode child = new TreeNode(i.ToString()+"****");
        child.Name = i.ToString() + "****";
        child.Text = i.ToString() + "****";
        children[i] = child;
    }
    return children;
}
//集合的方式
public TreeNode[] jiheGetTreeNodes()
{
    List<TreeNode> list = new List<TreeNode>();
    for (int i = 0; i < 5; i++)
    {
        TreeNode child = new TreeNode(i.ToString() + "****");            
        child.Name = i.ToString() + "****";
        child.Text = i.ToString() + "****";
        list.Add(child);
        //Zitree.Add(children);
    }
    return list.ToArray();
}
<font  color="DeepSkyBlue" >---//判断是否是数字 </font>
Regex regNum = new Regex("^[0-9]");
regNum.IsMatch（String ）; 返回值Bool
<font  color="DeepSkyBlue" >---//判断是数字还是字母 </font>
Regex.IsMatch(string, @"^[+-]?\d*[.]?\d*$"
<font  color="DeepSkyBlue" >---//判断这一天是星期几</font>
DateTime.now.DayOfWeek.ToString().ToUpper() == "SATURDAY" 写英文的星期
<font  color="DeepSkyBlue" >---//就是检查字符串长度是否超过int，不超过的左侧加0补足到int的长度 </font>
String.PadLeft(int,'0')   参数另行（int，char）
<font  color="DeepSkyBlue" >---//获得路径的后缀</font>
string extension = Path.GetExtension(_excelFilePath);
<font  color="DeepSkyBlue" >---//判断是否为空</font>
string.IsNullOrEmpty(value)
<font  color="DeepSkyBlue" >--//is  和 as 的使用</font>
List<string> columnNameList = new List<string>();
foreach (DataColumn col in dataDt.Columns)
{
 columnNameList.Add(col.ColumnName);//获取到DataColumn列对象的列名
}
<font  color="DeepSkyBlue" >---//C# 中 PadLeft ,PadRight的用法</font>
PadLeft 实现左边补足，Eg：String.PadLeft(10,'0'),就是检查字符串长度是否超过10，不超过的左侧加0补足到10的长度
PadRight 实现右边补足，Eg：String.PadRight (10,'0'),就是检查字符串长度是否超过10，不超过的右侧加0补足到10的长度
<font  color="DeepSkyBlue" >---//判断是否包含在里面  </font>
string value ="adffram";
value.Contains("M")
<font  color="DeepSkyBlue" >---//C# 基础之Const</font>
使用 const 关键字来声明某个常量字段或常量局部变量。常量字段和常量局部变量不是变量并且不能修改。 
常量可以为数字、布尔值、字符串或 null 引用（Constants can be numbers, Boolean values, strings, or a null reference）
（简单理解private 声明。声明的时候初始化并且赋予值，只读的。
却别与readonly 也是只读的，可以public  修饰，并且可以多次赋予值不一定在声明时赋值）
<font  color="DeepSkyBlue" >---//读取指定文档转化图片</font>
1.通过路径读取文档（返回string）string text = System.IO.File.ReadAllText(路径);
1.通过路径读取文档（返回string）
using (StreamReader sr = new StreamReader(路径))
{
    string line;
    // 从文件读取并显示行，直到文件的末尾 
    while ((line = sr.ReadLine()) != null)
    {
       return line;
    }
}
2. string转换byte类型 byte[] bb = Convert.FromBase64String(string );
3. byte类型转换image   MemoryStream ms = new MemoryStream(bb);
Image image = System.Drawing.Image.FromStream(ms);
 //-----------------------------------
 FileStream fs = new FileStream(@"E:\新建文件夹\FX20210305133318.bmp", FileMode.Open, FileAccess.Read);
 System.Drawing.Image originalImg = System.Drawing.Image.FromStream(fs);
 int a = originalImg.Width;
 //---------------------------------------
 Bitmap pic = new Bitmap(@"E:\新建文件夹\FX20210305133318.bmp");
 int width = pic.Size.Width;   // 图片的宽度
 int height = pic.Size.Height;   // 图片的高度
 //---------------------------------------
 System.Drawing.Image pic1 = System.Drawing.Image.FromFile(@"E:\新建文件夹\FX20210305133318.bmp");
 int width1 = pic1.Size.Width;   // 图片的宽度
 int height1 = pic1.Size.Height;   // 图片的高度
 <font  color="DeepSkyBlue" >---//路径的使用（path）</font>
 string path ="G:\Product\ISIE\ISIE.CutPic\bin\Debug\123.bmp";
 Path.GetFullPath(@"..//..")获得项目运行的上级目录
 Path.GetFullPath(@"..//..//..")获得项目运行的上上级目录
 Directory.Exists(path)--//判断某个文件夹是否存在
 file.Exists(path)--//判断某个文件夹里某个文件是否存在
 Directory.GetFiles(_PicPath, "*.bmp")--//获得文件里所以后缀为.bmp的
 Path.GetFileNameWithoutExtension(path)--// 返回123 (\bin\Debug\123.bmp)
 Path.GetFileName(path)--// 返回123.bmp (\bin\Debug\123.bmp)
  <font  color="DeepSkyBlue" >---//路径的使用（path）</font>
 Math.Sqrt(数字4,2);--//开方  return 2
 Math.Pow(数字4，2）；--//平方return 16
 
</span></pre></font></figure>
<h2 id=""><font size="5" color="Aqua" ><p>3.C# Datatable的基本使用</p></font></h2>	
<figure class="highlight bash"><pre><span class="line"><font size="4">
 dataTable.DefaultView.ToTable();
 dataTable.DefaultView.Sort = "";
 dataTable.DefaultView.ToTable().Copy();
 dataTable.DefaultView.RowFilter = "";
 dataTable.Copy();
 dataTable.Clone();
 dataTable.Clear();
 dataTable.AsEnumerable();
<font  color="DeepSkyBlue" >---//datatable 获得他的视图然后进行筛选</font>
dataTable.DefaultView.RowFilter就是对table操作不返回
dataTable.Select()返回 datarow[] 数组需要进行处理
最后采用datatable.Rows.Add(dataRow[0]);  或者  dT.ImportRow(dataRow[0]);
dataTable.DefaultView.Sort = "字段 asc";对table排序(排序字段为int类型)
<font  color="DeepSkyBlue" >--//C#中DataTable中的Compute方法使用收集</font>
DataTable.Compute(“expression”,”filter”);  参数一函数，参数二筛选条件
Expression： sum(列名)，avg(列名)，sum(列名)，min(列名)，max(列名)，count(列名) 
参考：https://blog.csdn.net/hello_mr_anan/article/details/81772803
//------------------------------
private void button1_Click(object sender, EventArgs e)
{
    dt_One.Clear();
    dt_One.Columns.Clear();
    dt_Two.Clear();
    dt_Two.Columns.Clear();
    CreatTable();
    dataGridView1.DataSource = dt_One;
    dataGridView2.DataSource = dt_Two;       
}
      public void CreatTable()
        {
            //dt_One
            DataColumn[] dataColumns = new DataColumn[101];
            dataColumns[0] = new DataColumn("One",typeof(string)); ;
            dataColumns[2] = new DataColumn("Three", typeof(string));
            dataColumns[3] = new DataColumn("Four", typeof(string)); 
            dt_One.Columns.AddRange(dataColumns);
            dt_One.Columns.Add("Two",typeof(string));
            dt_One.Columns["Two"].SetOrdinal(1);
            dt_One.Rows.Add(new string[] { "1111", "C语言程序设计","一","256"});
            dt_One.Rows.Add(new string[] { "2222", "Java程序设计", "二","300"});
            dt_One.Rows.Add(new string[] { "3333", "数据库概论", "一","200"});
            dt_One.Rows.Add(new string[] { "4444", "操作系统原理","二","100" });
            dt_One.Rows.Add(new string[] { "5555", "sqlserver", "二","44" });
            dt_One.Rows.Add(new string[] { "6666", "oracle", "二","88" });
            dt_One.Rows.Add(new string[] { "7777", "mysql", "一" ,"99"});
            //dt_Two
            dt_Two.Columns.Add("一");
            dt_Two.Columns.Add("二");
            dt_Two.Columns.Add("三");
            dt_Two.Columns.Add("四");
            dt_Two.Rows.Add("一", "22","");
            dt_Two.Rows.Add("一", "53", "");
            dt_Two.Rows.Add("二", "7", "");
            dt_Two.Rows.Add("二", "55", "");
            dt_Two.Rows.Add("二", "262", "");
            dt_Two.Rows.Add("一", "222", "");
            //-----------------Test1
            var Linq_table = from one in dt_One.AsEnumerable()
                             from two in dt_Two.AsEnumerable()
                             where one.Field<string>("Three") == two.Field<string>("一")
                             select new {
                                 Two = one.Field<string>("Two"),
                                   Three = one.Field<string>("Three")
                             };
            //-------------------------Test2
            var test_one = from DataRow one in dt_One.Rows
                           where one["Three"].ToString() == "一"
                           select new
                           {
                               Two = one.Field<string>("Two"),
                               Three = one.Field<string>("Three")
                           };
            DataTable test_one1 = LINQToDataTable(test_one.Distinct());
            var test_two = from DataRow two in dt_Two.Rows
                           where two["一"].ToString() == "一"
                           select new
                           {
                               一 = two.Field<string>("一")
                           };
            DataTable test_one2 = LINQToDataTable(test_two.Distinct());
            var last = from one in test_one
                       join two in test_two on one.Three equals two.一
                       select new {
                           Three =  one.Three,
                           二 = two.一
                       };      
            //dataGridView3.DataSource = LINQToDataTable(Linq_table.Distinct()); //Test1
            dataGridView3.DataSource = LINQToDataTable(last.Distinct()); //Test2
        }
        public DataTable LINQToDataTable<T>(IEnumerable<T> varlist)
        {
            DataTable dtReturn = new DataTable();
            // column names 
            PropertyInfo[] oProps = null;
            if (varlist == null) return dtReturn;
            foreach (T rec in varlist)
            {
                // Use reflection to get property names, to create table, Only first time, others 
                //will follow;
                 if (oProps == null)
                {
                    oProps = ((Type)rec.GetType()).GetProperties();
                    foreach (PropertyInfo pi in oProps)
                    {
                        Type colType = pi.PropertyType;

                        if ((colType.IsGenericType) && (colType.GetGenericTypeDefinition()
                        == typeof(Nullable<>)))
                        {
                            colType = colType.GetGenericArguments()[0];
                        }

                        dtReturn.Columns.Add(new DataColumn(pi.Name, colType));
                    }
                }
               DataRow dr = dtReturn.NewRow();
                foreach (PropertyInfo pi in oProps)
                {
                    dr[pi.Name] = pi.GetValue(rec, null) == null ? DBNull.Value : pi.GetValue
                    (rec, null);
                }
                dtReturn.Rows.Add(dr);
            }
            return dtReturn;
        }

</span></pre></font></figure>
<h2 id=""><font size="5" color="Aqua" ><p>4.C# EXCEL</p></font></h2>		
<figure class="highlight bash"><pre><span class="line"><font size="4">
IWorkbook workbook = new HSSFWorkbook();对应类型.xls
IWorkbook workbook = new XSSFWorkbook();对应类型.xlsx
用workbook创建sheet参数sheetName   ISheet sheet = workbook.CreateSheet(sheetName);
保存图片需要将图片转成byte的格式 然后用NPOI引用的IWorkbook workbook, ISheet sheet来处理
参数七是imgage转成的byte  参考网址https://blog.csdn.net/us2019/article/details/105403159
private static void Picture(IWorkbook workbook, ISheet sheet, int x, int y, int xc, int yc,byte[] bytes)
{  
    //第二步：将图片添加到workbook中  指定图片格式 返回图片所在workbook->Picture数组中的索引地址（从1开始）
    int pictureIdx = workbook.AddPicture(bytes, NPOI.SS.UserModel.PictureType.JPEG);
    //第三步：在sheet中创建画部
   IDrawing patriarch = sheet.CreateDrawingPatriarch();
    //第四步：设置锚点 （在起始单元格的X坐标0-1023，Y的坐标0-255，在终止单元格的X坐标0-1023，Y的坐标0-255，起始单元格行数，列数，终止单元格行数，列数）
    IClientAnchor anchor = patriarch.CreateAnchor(0, 0, 0, 0, x, y, xc, yc);
    //第五步：创建图片
    NPOI.SS.UserModel.IPicture pict = patriarch.CreatePicture(anchor, pictureIdx);
}
参考：https://blog.csdn.net/fenglele_fans/article/details/79268884方式很多
//将image转换成byte[]数据
private byte[] imageToByte(System.Drawing.Image _image)
{
    MemoryStream ms = new MemoryStream();
    _image.Save(ms,System.Drawing.Imaging.ImageFormat.Jpeg);
    return  ms.ToArray();
}
//将byte[]数据转换成image
private Image byteToImage(byte[]  myByte)
{
     MemoryStream ms = new MemoryStream(myByte);
     Image _Image = Image.FromStream(ms);
     return _Image;
}
<font  color="DeepSkyBlue" >--//指定位置添加数据</font>
sheet.AddMergedRegion(new NPOI.SS.Util.CellRangeAddress(3,6,7,10));合并单元格  四个参数（int firstRow, int lastRow, int firstCol, int lastCol）
可以参考网址很多https://blog.csdn.net/yh12346789/article/details/78766287
 HSSFWorkbook workbook = new HSSFWorkbook();对应类型.xls
//创建工作表
var sheet = workbook.CreateSheet("信息表");
//创建标题行（重点）
var row = sheet.CreateRow(0);
//创建单元格
var cellid = row.CreateCell(0);
cellid.SetCellValue("编号");
var cellname = row.CreateCell(1);
cellname.SetCellValue("用户名");
var cellpwd = row.CreateCell(2);
cellpwd.SetCellValue("密码");
var celltype = row.CreateCell(3);
celltype.SetCellValue("类型");

<font  color="DeepSkyBlue" >--//最后</font>
FileStream file = new FileStream(saveFileExcel.FileName, FileMode.CreateNew, FileAccess.Write);
 workbook.Write(file);
 file.Dispose();
<font  color="DeepSkyBlue" >--//Datatable 存取excel</font>
private void dataTableToCsv(DataTable table, string file)
{
    string title = "";
    FileStream fs = new FileStream(file, FileMode.OpenOrCreate);
    //FileStream fs1 = File.Open(file, FileMode.Open, FileAccess.Read);
    StreamWriter sw = new StreamWriter(new BufferedStream(fs), System.Text.Encoding.Default);
    for (int i = 0; i < table.Columns.Count; i++)
    {
        title += table.Columns[i].ColumnName + "\t"; //栏位：自动跳到下一单元格
    }
    title = title.Substring(0, title.Length - 1) + "\n";
    sw.Write(title);
    foreach (DataRow row in table.Rows)
    {
        string line = "";
        for (int i = 0; i < table.Columns.Count; i++)
       {
            line += row[i].ToString().Trim() + "\t"; //内容：自动跳到下一单元格

        }
        line = line.Substring(0, line.Length - 1) + "\n";
        sw.Write(line);
    }
    sw.Close();
    fs.Close();
}
<font  color="DeepSkyBlue" >--//弹框选择类型</font>
SaveFileDialog saveFile = new SaveFileDialog();
saveFile.Title = "请选择文件存放路径";
saveFile.Filter = "Excel文档(*.xls)|*.xls|Excel文档(*.xlsx)|*.xlsx";
//saveFile.FileName =  DateTime.Now.ToString("yyyyMMddHhmmss");
if (saveFile.ShowDialog() == DialogResult.OK)
{}
<font  color="DeepSkyBlue" >--//将table遍历添加到指定位置</font>
IRow row1;
int num = 14;从14行开始添加
if (dataTable.Rows.Count > 0)
{
    for (int i = 0; i < dataTable.Rows.Count; i++)
    {
        row1 = sheet.CreateRow(num + i);
        row1.CreateCell(0).SetCellValue(dataTable.Rows[i][i].ToString());第一列或者通过列名指定某一列
        row1.CreateCell(1).SetCellValue(dataTable.Rows[i][i+1].ToString());
        row1.CreateCell(2).SetCellValue(dataTable.Rows[i][i+2].ToString());
        row1.CreateCell(3).SetCellValue(dataTable.Rows[i][i + 3].ToString());
        row1.CreateCell(4).SetCellValue(dataTable.Rows[i][i + 4].ToString());

    }
}
</span></pre></font></figure>
<h2 id=""><font size="5" color="Aqua" ><p>5.C# XML</p></font></h2>	
<figure class="highlight bash"><pre><span class="line"><font size="4">
--/获得指定标签下的值
<xmp><a>
	<b>
		<b1>1</b1>
	</b>
	<c>
		<c1>1</c1>
	</c>
</a></xmp>
XmlDocument xmlDoc = new XmlDocument();
string path =路径;
if (File.Exists(path))
{
    //加载xml
    xmlDoc.Load(path);
    XmlNode xn = xmlDoc.SelectSingleNode("a/b");    
    string str = (xn.SelectSingleNode("b1")).InnerText;
}
--//删除指定标签
<xmp><a>
	<b name='1'>
	<b>
	<b name='2'>
	<b>
</a></xmp>
public void delete()
{
    /XElement xele = xdoc.Root.Element("元素名");
    ////如果你要根据属性来查询的话，这么用
    //IEnumerable<XElement> xeles = from xel in xdoc.Root.Descendants()
    //                              where xel.Attribute("name").Value == "1"
    //                              select xel;
    string xmlpath = 路径;
    XDocument xdoc = XDocument.Load(xmlpath);
    IEnumerable<XElement> C = xdoc.Element("a").Elements();
    foreach (XElement tmp in C)
    {
        int count = C.Count();
        if (tmp.Name == "b")
        {
            if (tmp.Attribute("Name").Value == "1")
            {
                tmp.Remove();
            }
        }

    }
    xdoc.Save(xmlpath);
}
</span></pre></font></figure>
<h2 id=""><font size="5" color="Aqua" ><p>6.C# 切割图片以及画图GDI简单使用和总结</p></font></h2>	
<figure class="highlight bash"><pre><span class="line"><font size="4">
<font  color="DeepSkyBlue" >--//Gdal使用处理超过2g图片</font>
https://www.gisinternals.com/  官网下载dll
参考：https://blog.csdn.net/u010771437/article/details/45248215 使用
https://blog.csdn.net/rsyaoxin/article/details/9220735
<font  color="DeepSkyBlue" >--//基本类</font>
 Bitmap bmp = new Bitmap(path);指定路径获得图片（Bitmap）类型
Image Img = FromFile(path);指定路径获得图片（Image）类型
RectangleF（）PointF（）SizeF（）类都存在线束小数类型和整数类型Rectangle（）Point（）
<font  color="DeepSkyBlue" >--//Bitmap可以直接复制图片的某部分出来然后保存</font>
bmp.Clone(new RectangleF(StartX, StartY, pPartWidth, pPartHeight), bmp.PixelFormat).Save(SavePath); 
<font  color="DeepSkyBlue" >--//方法二 也可以 Graphics.DrawImage();</font>
// 获取图片指定部分
/// </summary>
/// <param name="originalImg">图片</param>
/// <param name="pPartStartPointX">目标图片开始绘制处的坐标X值(通常为0)</param>
/// <param name="pPartStartPointY">目标图片开始绘制处的坐标Y值(通常为0)</param>
/// <param name="pPartWidth">目标图片的宽度</param>
/// <param name="pPartHeight">目标图片的高度</param>
/// <param name="pOrigStartPointX">原始图片开始截取处的坐标X值</param>
/// <param name="pOrigStartPointY">原始图片开始截取处的坐标Y值</param>
/// PointF
 static System.Drawing.Bitmap GetPart(Image originalImg, float pPartStartPointX, float pPartStartPointY, int pPartWidth, int pPartHeight, float pOrigStartPointX, float pOrigStartPointY)
 {
     //System.Drawing.Image originalImg = System.Drawing.Image.FromFile(pPath);

     System.Drawing.Bitmap partImg = new System.Drawing.Bitmap(pPartWidth, pPartHeight);
     System.Drawing.Graphics graphics = System.Drawing.Graphics.FromImage(partImg);
     System.Drawing.RectangleF destRect = new System.Drawing.RectangleF(new System.Drawing.PointF(pPartStartPointX, pPartStartPointY), new System.Drawing.SizeF(pPartWidth, pPartHeight));//目标位置
     System.Drawing.RectangleF origRect = new System.Drawing.RectangleF(new System.Drawing.PointF(pOrigStartPointX, pOrigStartPointY), new System.Drawing.SizeF(pPartWidth, pPartHeight));//原图位置（默认从原图中截取的图片大小等于目标图片的大小）

     graphics.DrawImage(originalImg, destRect, origRect, System.Drawing.GraphicsUnit.Pixel);

     return partImg;
 }
 <font  color="DeepSkyBlue" >--//Graphics 画圆;</font>
   Graphics gra = e.Graphics;
   Pen p = new Pen(Color.Black, 2);          
   gra.DrawEllipse(p, _X, Y,w , h);
   --//画个正方形
   g.DrawRectangle(new Pen(Color.Black),X,Y,Width,Height);//
   g.FillRectangle(new Pen(Color.Black),X,Y,Width,Height);//填充颜色
--//GDAL处理图片的方法
 static void GDAlGetCutPicture(String srcFileName, int LeftAndRightSpacing, int TopAndBottomSpacing, int StartPointX, int StartPointY, int pPartWidth, int pPartHeight)
  {
    try
    {
        if (File.Exists(srcFileName))
        {
            Gdal.AllRegister();
            Dataset srcDs = Gdal.Open(srcFileName, Access.GA_ReadOnly);
            DataType srcType = srcDs.GetRasterBand(1).DataType;
            int bandCount = srcDs.RasterCount;
            double[] adfGeoTransform = new double[6];
            srcDs.GetGeoTransform(adfGeoTransform);
            int StartX = StartPointX;// 开始的X
            int StartY = StartPointY;// 开始的Y
            int width = srcDs.RasterXSize;  // 图片的宽度
            int height = srcDs.RasterYSize; // 图片的高度

            for (int i = 1; i <= (height - StartPointY) / (pPartHeight + TopAndBottomSpacing); i++)//行
            {
                for (int j = 1; j <= (width - StartPointX) / (pPartWidth + LeftAndRightSpacing); j++)//列
                {
                    //CreatFile(Path.GetDirectoryName(path));
                    //String SavePath = Path.GetDirectoryName(path).ToString() + @"\" + "Cut_" + Path.GetFileName(path) + @"\" + i + "-" + j + ".bmp";
                    //String SavePath = Path.GetDirectoryName(_PicPath).ToString() + @"\" + Path.GetFileName(_PicPath) + @"\" + "Cut_" + Path.GetFileNameWithoutExtension(srcFileName) + @"\" + i + "-" + j + ".bmp";
                    String SavePath = SvaePath + @"\" + "Cut_" + Path.GetFileNameWithoutExtension(srcFileName) + @"\" + i + "-" + j + ".bmp";
                    Driver drv = Gdal.GetDriverByName("GTIFF");
                    Dataset dstDs = drv.Create(SavePath, pPartWidth, pPartHeight, bandCount, srcType, null);
                    dstDs.SetGeoTransform(adfGeoTransform);
                    dstDs.SetProjection(srcDs.GetProjectionRef());
                    int[] bandArray = new int[bandCount];
                    for (int y = 0; y < bandCount; y++)
                    {
                        bandArray[y] = y + 1;
                    }
                    int[] dataArray = new int[pPartWidth * pPartHeight * bandCount];
                    srcDs.ReadRaster(StartX, StartY, pPartWidth, pPartHeight, dataArray, pPartWidth, pPartHeight, bandCount, bandArray, 0, 0, 0);
                    dstDs.WriteRaster(0, 0, pPartWidth, pPartHeight, dataArray, pPartWidth, pPartHeight, bandCount, bandArray, 0, 0, 0);
                    dstDs.FlushCache();
                    if (j == 1)
                    {
                        StartX = StartPointX + pPartWidth + LeftAndRightSpacing;
                    }
                    else
                    {
                        StartX += pPartWidth + LeftAndRightSpacing;
                    }
                }
                StartX = StartPointX;
                if (i == 1)
                {
                    StartY = StartPointY + pPartHeight + TopAndBottomSpacing;
                }
                else
                {
                    StartY += pPartHeight + TopAndBottomSpacing;
                }
            }
            srcDs.Dispose();
            //dstDs.Dispose();
        }
    }
    catch (Exception e)
    {
       throw;
    }
}
   
</span></pre></font></figure>
							
							<figure class="highlight bash">
								
								
							</figure>
							<figure class="highlight bash">
								<table>
									<tr>
										<td class="gutter"><pre>
												<span class="line">1</span><br>
											</pre></td>
										<td class="code"><pre>
	                                                     <span class="line">$ hexo deploy</span><br>
											</pre></td>
									</tr>
								</table>
							</figure>

							

						</div>

						<div class="article-info article-info-index">
					<div class="clearfix"></div>
						</div>
					</div>

				</article>
			</div>
			<footer id="footer">
				<div class="outer">
					<div id="footer-info">
						<div class="footer-left">&copy; 2020 XU LIN</div>
						<div class="footer-right">
							<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a
								href="https://github.com/smackgg/hexo-theme-smackdown"
								target="_blank">Smackdown</a>
						</div>
					</div>
				</div>
			</footer>
		</div>


		<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



		<script>
			var yiliaConfig = {
				fancybox : true,
				mathjax : true,
				animate : true,
				isHome : true,
				isPost : false,
				isArchive : false,
				isTag : false,
				isCategory : false,
				open_in_new : false
			}
		</script>

		<script src="/js/main.js"></script>




		<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

		<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


	</div>
</body>
</html>

